## Contraintes et héritage

Arrivé ici, vous devriez avoir les classes suivantes :
- `Dipole`
  - `Resistance`
  - `Capacitor`
  - `Inductor`
  - `Series`
  - `Parallel`
- `Filter`
  - `RCFilter`
  - `RLCFilter`

Dans la classe `Dipole`, il y a un champ `nom` qui a été marqué comme `protected` pour qu'il soit accessible par les classes filles ; elles peuvent ainsi lui assigner une valeur dans leur constructeur, exemple :

```csharp
public Resistance(string nom, double resistance) {
    this.nom = nom;
    this.resistance = resistance;
}
```

On rappelle que pour créer un objet, on fait `new Classe(...)` et que cela appelle le constructeur de la classe. De fait, si on assigne un champ dans le constructeur, on a la garantie qu'il sera toujours initialisé (car tout objet a, à un moment ou un autre, été créé par le constructeur).

Cependant, que se passe-t-il si je crée la classe suivante :

```csharp
public class Truc : Dipole {
    private string bidule;

    public Truc(string bidule) {
        this.bidule = bidule;
    }
}
```

Je n'ai pas assigné le champ `nom` de `Dipole` ! Il sera donc `null` et ça causera une erreur plus tard (si j'essaie de manipuler le nom du composant en pensant qu'il n'est pas `null`).

Il faudrait donc, pour `Dipole`, un moyen de forcer les classes filles à fournir une valeur de nom. On peut pour cela définir un constructeur dans `Dipole` qui prend un nom en argument, et forcer les classes filles à appeler ce constructeur. Comme `Dipole` est abstraite, on ne peut pas l'instancier directement, mais ses classes filles peuvent appeler son constructeur avec `: base(...)` :

```csharp
public abstract class Dipole {
    protected string nom;

    protected Dipole(string nom) {
        this.nom = nom;
    }

    /* ... */
}

public class Truc : Dipole {
    private string bidule;

    public Truc(string nom, string bidule) : base(nom) { // appel du constructeur de Dipole avec base(...)
        this.bidule = bidule;
    }
}
```

Modifiez donc `Dipole` et ses classes filles de la sorte.

Pour rendre ça utile, vérifiez dans le constructeur de `Dipole` que le nom n'est pas vide ou `null` (à l'aide de `string.IsNullOrWhiteSpace`), et lancez une exception `ArgumentException` si c'est le cas.

> [!TIP]
> Une exception est un objet comme un autre. On peut en créer avec `new` et les lancer avec le mot-clé `throw`, par exemple :
> ```csharp
> throw new ArgumentException("Le nom ne peut pas être vide");
> throw new InvalidOperationException("Opération invalide");
> throw new NotImplementedException("Pas encore implémenté");
> ```

Modifiez également les constructeurs de vos diverses classes pour vérifier que les valeurs sont raisonnables (par exemple, une résistance, une capacité ou une inductance ne peuvent pas être négatives).

---

On va tester ça avec un peu d'interactivité : dans le programme principal, demandez à l'utilisateur de saisir le nom et la valeur d'une résistance, créez la résistance, puis affichez-la.

> [!TIP]
> Pour lire une ligne de texte dans la console, utilisez `Console.ReadLine()`. Pour convertir une chaîne de caractères en nombre, utilisez `double.Parse(...)`.

Que se passe-t-il si l'utilisateur rentre une valeur négative, ou un nom vide ? Que se passe-t-il si l'utilisateur entre un texte au lieu d'un nombre ?

---

Les exceptions sont le mécanisme standard en C# (et en Java, Python, etc.) pour gérer les erreurs. Si une exception n'est pas interceptée, le programme s'arrête et affiche un message d'erreur.

Il est possible d'intercepter les exceptions avec `try` / `catch` :

```csharp
try {
    int x = 8;
    int y = 0;
    int z = x / y; // génère une exception de type DivideByZeroException
} catch (Exception e) {
    Console.WriteLine($"Une erreur est survenue : {e.Message}"); // affiche "Une erreur est survenue : Division by zero."
}
```

Modifiez votre programme principal pour intercepter les exceptions qui pourraient être générées lors de la création de la résistance, et affichez un message d'erreur à l'utilisateur. Et mettez le tout dans une boucle pour que l'utilisateur puisse réessayer jusqu'à ce qu'il entre une valeur correcte.

Votre programme devrait ressembler à ça quand vous l'exécutez :

```
** Entrez le nom de la résistance :
R1
** Entrez la valeur de la résistance (en Ohms) :
-1000
!! Erreur : La résistance ne peut pas être négative.
** Entrez le nom de la résistance :
R1
** Entrez la valeur de la résistance (en Ohms) :
1000
-- Résultat : Res(R1, 1000 Ω)
```
