## Extraction du test

Vous avez normalement trois fois dans votre code des lignes qui affichent une résistance, puis la tension aux bornes pour un courant donné.

Extrayez ce code dans une fonction (dans `Program.cs`) qui prendra comme paramètre une instance de `Resistance` et un courant, et qui affichera les informations demandées.

## Deuxième composant : le condensateur

Créez une seconde classe `Capacitor` pour modéliser un condensateur. Un condensateur est caractérisé par sa capacité $C$ (en Farads, $\mathrm{F}$). Dans un circuit en régime continu, un condensateur se comporte comme un circuit ouvert (i.e. il ne laisse pas passer le courant). Sa résistance est donc $+\infty$.

> [!TIP]
> Les types entiers, dont `double`, fournissent des constantes mathématiques pour des valeurs courantes. Écrivez `double.` dans l'IDE et voyez ce qui vous est suggéré.

Affichez votre condensateur dans la console (créez éventuellement la ou les méthodes nécessaires dans la classe), par exemple `Cap(C1, 1E-06 F)`, et affichez la tension aux bornes du condensateur pour un courant de $2 \mathrm{mA}$.

Si seulement on pouvait éviter de dupliquer le code entre les résistances et les condensateurs... une idée ?

Trouvez un moyen de résoudre ce problème de sorte à ce que je puisse faire :

```csharp
Resistance R1 = new Resistance("R1", 1e3);
Capacitor C1 = new Capacitor("C1", 1e-6);

DisplayComponent(R1, 2e-3); // affiche "Res(R1, 1000 Ω), U=2 V"
DisplayComponent(C1, 2e-3); // affiche "Cap(C1, 1E-06 F), U=∞ V"
```

> [!NOTE]
> Si le programme affiche `8` au lieu de `∞`, ou `O` au lieu de `Ω`, ajoutez cette ligne au début de votre programme: 
> ```csharp
> Console.OutputEncoding = System.Text.Encoding.UTF8;
> ```

> [!TIP]
> Dans une classe mère, `virtual` signifie que la méthode peut être redéfinie dans une classe fille – utile quand la méthode a une implémentation par défaut (comme `ToString`) qui peut être utilisée faute de mieux.
>
> À l'inverse, vous pouvez utiliser `abstract` pour forcer les classes filles à implémenter la méthode, sans fournir d'implémentation par défaut. Par exemple,
> ```csharp
> public abstract class Forme {
>     public abstract double Aire(); // pas d'implémentation
> }
> public class Cercle : Forme {
>     private double rayon;
>     public override double Aire() {
>         return Math.PI * rayon * rayon;
>     }
> }
> public class Carre : Forme {
>     private double cote;
>     public override double Aire() {
>         return cote * cote;
>     }
> }
> ```
> **NB** : Une classe abstraite ne peut pas être instanciée directement, par exemple `Forme f = new Forme();` est interdit (à la fois, ça n'aurait pas de sens).
> 
> **NB 2** : Une classe qui contient au moins une méthode abstraite doit être elle-même déclarée abstraite.

Vous devriez vous retrouver avec trois classes dont deux qui héritent de la première, et une fonction `DisplayComponent` qui prend en argument un objet de la classe mère.

Tant qu'à faire, déplacez aussi l'attribut de nom dans la classe mère – après tout, tous les composants auront un nom. Rencontrez-vous des problèmes ? Pourquoi ?

> [!TIP]
> `private` marque l'élément comme accessible uniquement dans sa classe. `protected` permet de le rendre accessible dans les classes filles aussi.