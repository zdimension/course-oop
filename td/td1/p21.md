## Collections, séquences, opérations de flux

Jusqu'ici, nous avons vu le type le plus simple de séquence d'éléments en C# : le tableau (array), qui est caractérisé par le type de ses éléments et se note `T[]`. Un tableau a la spécificité d'avoir une taille fixe lors de sa création :
- soit on crée un tableau vide d'une taille donnée : `new T[n]`
- soit on crée un tableau initialisé avec des éléments donnés : `new T[] { elem1, elem2, ... }` ou (syntaxe plus récente) `[ elem1, elem2, ... ]` (et la taille est "devinée" par les éléments fournis)

On peut parcourir un tel tableau avec la boucle `foreach`.

Il existe un autre type important de séquence en C# : les listes (`List`). Celles-ci sont définies dans l'espace de nom `System.Collections.Generic`, donc il faut ajouter `using System.Collections.Generic;` en haut du fichier pour pouvoir les utiliser (mais Rider le fera pour vous).

On note `List<T>` une liste d'éléments de type `T`. Contrairement aux tableaux, les listes peuvent changer de taille dynamiquement : on peut ajouter ou retirer des éléments à tout moment :

```csharp
List<int> nombres = new List<int>(); // liste vide
nombres.Add(42); // ajoute 42 à la liste
nombres.Add(6); // ajoute 6 à la liste
nombres.Add(7); // ajoute 7 à la liste
Console.WriteLine(nombres.Count); // affiche 3
nombres.Remove(6); // retire 6 de la liste
foreach (int n in nombres) {
    Console.WriteLine(n); // affiche 42 puis 7
}
```

Il existe une syntaxe spéciale qui permet de créer et initialiser une liste en une seule ligne :

```csharp
List<int> nombres = new List<int> { 42, 6, 7 };
```

> [!TIP]
> Cette syntaxe fonctionne pour toute collection, en fait, et se traduit par des appels successifs à la méthode `Add` de la collection.
>
> Le code ci-dessus est donc rigoureusement équivalent au premier exemple !

Comme `IComparable`, `List` est un type générique qui a un paramètre de type `T` (le type des éléments de la liste). Vous pouvez créer des listes d'entiers (`List<int>`), de chaînes de caractères (`List<string>`), ou même de vos propres types (par exemple, `List<Dipole>`).

---

On voudrait que notre fonction `FindMax` puisse traiter non seulement des tableaux, mais aussi des listes (et potentiellement d'autres types de séquences). Si seulement `T[]` et `List<T>` avaient une interface commune...

Voici `IEnumerable<T>` :

```csharp
public interface IEnumerable<T>
{
    IEnumerator<T> GetEnumerator();
}
```

Pas besoin de comprendre le détail de cette interface pour l'instant, mais sachez que `T[]` et `List<T>` implémentent toutes les deux cette interface, et que c'est ce qu'utilise `foreach` pour pouvoir itérer (énumérer) dans une séquence.

Modifiez `FindMax` et vérifiez que vous pouvez donc faire ceci :

```csharp
int[] tableau = new int[] { 3, 1, 4 };
List<int> liste = new List<int> { 3, 1, 4 };

Console.WriteLine("Max dans le tableau : " + FindMax(tableau));
Console.WriteLine("Max dans la liste : " + FindMax(liste));
```

---

C# fournit un ensemble très riche d'opérations sur les séquences appelé "LINQ" (Language Integrated Query). Parmi celles-ci, on trouve des opérations de filtrage (`Where`), de transformation (`Select`), de regroupement (`GroupBy`), qui devraient toutes vous rappeler des heureux souvenirs. Voici quelques exemples :

```csharp
List<int> nombres = new List<int> { 1, 2, 3, 4, 5, 6 };
// garder seulement les nombres pairs
IEnumerable<int> pairs = nombres.Where(n => n % 2 == 0);
// élever chaque nombre au carré
IEnumerable<int> carres = nombres.Select(n => n * n);
// afficher les résultats
foreach (int n in pairs) {
    Console.WriteLine(n); // affiche 2, 4, 6
}
```

> [!TIP]
> Ce n'est plus trop à la mode ces dernières années, mais C# permet également d'écrire ces opérations de flux avec une syntaxe inspirée du SQL, appelée "query syntax". Par exemple, le code ci-dessus peut se réduire et s'écrire ainsi :
> ```csharp
> IEnumerable<int> resultat = from n in nombres
>                             where n % 2 == 0
>                             select n * n;
> foreach (int n in resultat) {
>     Console.WriteLine(n); // affiche 4, 16, 36
> }
> ```

---

Si vous êtes arrivés jusqu'ici, bravo. Vous êtes allés plus loin que prévu pour cette matière, je ne peux que vous recommander de relire vos précédents TDs et réviser le DS.