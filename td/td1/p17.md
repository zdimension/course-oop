## Propriétés

Vous l'aurez compris, un mot-clé essentiel de ce cours est l'encapsulation :
- les classes encapsulent des données (leurs champs) pour conserver des garanties / invariants
- les classes encapsulent aussi des comportements (leurs méthodes) pour fournir une interface simple et cohérente aux utilisateurs de la classe

De façon plus générale, les langages de programmation encapsulent des fonctionnalités dans des concepts :
- le fait de regrouper plusieurs lignes de code ensemble constitue la notion de bloc (`{ ... }`)
- le fait de regrouper des blocs réutilisables constitue la notion de fonction / méthode
- le fait de regrouper des données et des comportements constitue le concept de classe, donc les langages objets vous fournissent la notion de classe.

Nouveau concept utile : jusqu'ici on a pris l'habitude de marquer les champs `private` et de parfois doter les classes de fonctions `GetTruc()` qui renvoie la valeur du champ. Ainsi, l'extérieur ne peut pas modifier les champs et on évite le risque que l'état interne de l'objet soit corrompu. On peut aussi avoir une fonction `SetTruc(valeur)`.

Ce motif (champ + fonction de lecture + fonction d'écriture) est tellement courant qu'il existe une syntaxe raccourcie pour le faire en C# : les **propriétés**.

> [!TIP]
> Les propriétés constituent ce qu'on appelle du **sucre syntaxique** : c'est un "raccourci" de code. Quand vous écrivez une propriété, lors de la compilation, elle est traduite en un champ et deux fonctions.

Voici un exemple de code :
```csharp
public class Personne {
    private string _nom;
    private int _poids;

    public string GetNom() {
        return _nom;
    }

    public int GetPoids() {
        return _poids;
    }

    public void SetPoids(int valeur) {
        if (valeur < 0) {
            throw new ArgumentException("Le poids ne peut pas être négatif");
        }
        _poids = valeur;
    }

    public Personne(string nom, int poids) {
        this._nom = nom;
        this.SetPoids(poids); // on utilise la fonction pour bénéficier de la validation
    }
}
```
Et voici le même code, mais utilisant des propriétés à la place des fonctions `Get` et `Set` :
```csharp
public class Personne {
    private string _nom;
    private int _poids;

    public string Nom {
        get { return nom; }
        // pas de "set" car le nom est constant
    }

    public int Poids {
        get { return _poids; }
        set { 
            // dans un "set", la valeur assignée est accessible via le mot-clé "value"
            if (value < 0) {
                throw new ArgumentException("Le poids ne peut pas être négatif");
            }
            _poids = value;
        }
    }

    public Personne(string nom, int poids) {
        this._nom = nom;
        this.Poids = poids; // on utilise la propriété pour bénéficier de la validation
    }
}
```

Une propriété s'utilise comme un champ, c'est d'ailleurs le but : masquer le fait qu'il y a des fonctions derrière. Par exemple :
```csharp
Personne p = new Personne("Alice", 60);
Console.WriteLine($"Nom : {p.Nom}, Poids : {p.Poids} kg");
p.Poids = 62; // on modifie le poids via la propriété
Console.WriteLine($"Nouveau poids : {p.Poids} kg");
p.Poids = -5; // va planter en déclenchant une exception
```

Vous pouvez voir comment utiliser des propriétés permet de simplifier l'encodage de contraintes. Si on se force à ne jamais écrire dans le champ `_poids` mais toujours en passant par la propriété `Poids`, on est sûr que le poids ne sera jamais négatif. C'est un invariant de la classe.

---

De façon générale, c'est une bonne pratique de ne jamais avoir de champs publics, même s'ils sont conçus pour être modifiables sans restriction. Imaginons :
```csharp
class Compteur {
    public int Valeur; // peut avoir n'importe quelle valeur
}
```
Ici, aucune vérification à faire. Mais si on décide plus tard qu'on veut que la valeur soit toujours positive, on ne pourra pas le faire sans casser le code qui utilise la classe `Compteur`, car remplacer un champ par une propriété est un changement cassant (des choses peuvent cesser de marcher car on change la nature de l'élément).

Ce qu'on pourra faire est donc :
```csharp
class Compteur {
    private int _valeur;

    public int Valeur {
        get { return _valeur; }
        set { _valeur = value; }
    }
}
```
Le comportement est identique à un champ, mais comme c'est d'emblée une propriété, on peut librement rajouter du code à l'avenir. Si plus tard on veut afficher un message dans la console à chaque changement, on peut faire:
```csharp
set { 
    Console.WriteLine($"Changement de valeur : {_valeur} -> {value}");
    _valeur = value; 
}
```

---

Modifiez donc vos classes `Resistance`, `Capacitor`, `Inductor` pour utiliser une propriété pour leur valeur. Cette propriété sera modifiable mais vérifiera que la valeur est positive (sinon elle lèvera une exception `ArgumentException`). Naturellement le constructeur de ces classes utilisera la propriété pour initialiser la valeur.

---

Testez en créant des composants avec des valeurs fantaisistes et vérifiez que les exceptions sont bien levées quand vous essayez de leur donner des valeurs négatives.