## Structures

On a vu plus tôt que le type `Complex` (fourni par `System.Numerics`) permet de modéliser des nombres complexes :

```csharp
using System.Numerics;

Complex z1 = new Complex(1, 2);
Complex z2 = new Complex(3, 4);
Console.WriteLine(z1); // affiche "<1; 2>"
Complex z3 = z1 + z2;
Console.WriteLine(z3); // affiche "<4; 6>"
```

Nous allons créer nos propres nombres complexes.

À quoi cela pourrait-il ressembler ?

Une première ébauche :

```csharp
public class MyComplex {
    public double Real;
    public double Imaginary;

    public MyComplex(double real, double imaginary) {
        this.Real = real;
        this.Imaginary = imaginary;
    }
}
```

Bien, mais comme on a vu à la page d'avant, il serait préférable de rendre les champs `Real` et `Imaginary` **privés** (en les renommant `_real` et `_imaginary`), et de fournir des **propriétés** en lecture seule pour y accéder (lecture seule car on ne modifiera jamais un complexe directement, c'est un nombre).

---

Ensuite, notion importante : un nombre complexe n'a pas d'identité. Qu'est-ce que ça veut dire ?

Les objets qu'on a pu créer jusqu'ici, les comptes courantes, les animaux, les personnes, etc., ont une identité : deux comptes courants avec le même solde sont quand même deux comptes différents. Deux personnes avec le même nom sont quand même deux personnes différentes. 

En revanche, d'autres objets de la vie réelle sont dépourvus d'identité : deux nombres "3" sont identiques, deux nombres complexes "1 + 2i" sont identiques. On dit que ces objets se comportent comme des **valeurs**.

En C#, la différence se fait dans leur définition :
- un objet avec identité est défini via une **classe** (`class`)
- un objet sans identité est défini via une **structure** (`struct`)

Les deux fonctionnent de la même manière, et peuvent contenir champs, méthodes, et propriétés. 

Une différence importante, notamment en développement embarqué, est qu'une structure consomme moins de ressources qu'une classe. Ouvrons une parenthèse.

> [!NOTE]
> On peut généralement distinguer deux types de mémoire dans un programme :
> - la **pile** (stack) : mémoire rapide, utilisée pour les variables locales, mais de taille limitée
> - le **tas** (heap) : mémoire plus lente, utilisée pour les objets dynamiques, mais de taille plus grande.
>   - en C, la fonction `malloc` sert à allouer de la mémoire sur le tas.
> 
> Certains langages comme le Python n'offrent pas de contrôle sur ces aspects, et tout est généralement alloué sur le tas.
>
> D'autres, comme le C ou le C#, permettent de choisir où sont placées les choses selon leur type. En C#, les types définis via `class` sont toujours alloués sur le tas, tandis que les types définis via `struct` sont alloués sur la pile. Conséquence : instancier une `class` coûte du temps (allocation sur le tas), mais instancier une `struct` est quasi gratuit (allocation sur la pile).
>
> Comme l'allocation sur la pile est quasi gratuite, les structures sont passées par **copie**, là où les classes sont passées par **référence**. Exemple :
> ```csharp
> class MaClasse {
>   public int Valeur;
> }
> struct MaStructure {
>   public int Valeur;
> }
>
> MaClasse c = new MaClasse();
> c.Valeur = 10;
> MaClasse c2 = c; // c2 référence le même objet que c
> c2.Valeur = 20; // change la valeur de c car les deux variables pointent vers le même objet
>
> MaStructure s = new MaStructure();
> s.Valeur = 10;
> MaStructure s2 = s; // s2 est une copie de s
> s2.Valeur = 20; // ne change pas s car s2 est une copie
> 
> void ModifierClasse(MaClasse obj) {
>   obj.Valeur = 42; // modifie l'objet original
> }
> void ModifierStructure(MaStructure obj) {
>   obj.Valeur = 42; // modifie une copie locale
> }
>
> ModifierClasse(c); // c.Valeur devient 42
> ModifierStructure(s); // s.Valeur reste 10 car le paramètre `obj` contient une copie

Il convient donc de conclure que nos nombres complexes seront modélisés via une structure et non une classe.

À vous donc de créer une structure avec deux propriétés `Real` et `Imaginary`, ainsi qu'un constructeur. Vous ajouterez aussi une méthode `ToString` pour afficher un nombre complexe sous la forme "a + bi".

```csharp
MyComplex z = new MyComplex(1, 2);
Console.WriteLine(z); // affiche "1 + 2i"
```


Vous rajouterez également une propriété `Magnitude` qui renverra le module et une propriété `Phase` qui renverra l'argument (en radians) du nombre complexe. 

On rappelle que pour un nombre complexe $z = a + bi$ :

$$|z| = \sqrt{a^2 + b^2}$$

$$\arg(z) = \mathrm{atan2}(b, a)$$

La fonction $\mathrm{atan2}(y, x)$ est disponible en C# via `Math.Atan2(y, x)`.

Il faut savoir que :

> [!TIP]
> Une propriété peut exister de façon "virtuelle" sans qu'il y ait de champ derrière. Par exemple, on peut avoir :
> ```csharp
> struct Temperature {
>     private double _valeur; // en Celsius
>     public double Celsius {
>         get { return _valeur; }
>         set { _valeur = value; }
>     }
>     public double Fahrenheit {
>         get { return _valeur * 9.0 / 5.0 + 32.0; }
>         set { _valeur = (value - 32.0) * 5.0 / 9.0; }
>     }
> }
> ```
> Ici, la propriété `Fahrenheit` n'a pas de champ dédié, mais calcule sa valeur à partir de la valeur en Celsius. De même, lorsqu'on assigne une valeur à `Fahrenheit`, on met à jour le champ `_valeur` en Celsius.
>
> Cela permet d'avoir deux éléments (Celsius et Fahrenheit) qui ont la même "forme" (une propriété) vu de l'extérieur :
>
> ```csharp
> Temperature t = new Temperature();
> t.Celsius = 100;
> Console.WriteLine(t.Fahrenheit); // affiche 212
> t.Fahrenheit = 32;
> Console.WriteLine(t.Celsius); // affiche 0
> ```

### Test de performance

Il existe une classe `System.Diagnostics.Stopwatch` qui permet de mesurer le temps d'exécution d'un bout de code.

```csharp
using System.Diagnostics;

Stopwatch stopwatch = new Stopwatch();
stopwatch.Start();

// Code à mesurer
// Chaque appel prend peu de temps, donc on le répète
// un grand nombre de fois pour obtenir une mesure significative
for (int i = 0; i < 1000000; i++) {
    Math.Sqrt(i);
}

stopwatch.Stop();
Console.WriteLine($"Temps écoulé : {stopwatch.ElapsedMilliseconds} ms");
```

Créez une **classe** `MyComplex2` qui contient juste les deux champs `Real` et `Imaginary` publics (comme une structure classique), ainsi qu'un constructeur, rien de plus. Comparez ensuite le temps d'exécution pour simpler créer (`new`) un grand nombre de complexes, entre `MyComplex` (structure) et `MyComplex2` (classe). Si la mesure est trop rapide, augmentez le nombre d'itérations. Qu'observez-vous ?