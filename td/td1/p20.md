## Généricité

Écrivez une fonction `FindMax` qui prend un tableau d'ints et renvoie le plus grand. Vous pourrez supposer que le tableau passé contient toujours au moins 1 élément.

```csharp
FindMax([3, 1, 4, 1, 5, 9]) // renvoie 9
FindMax([-2, -3, -1]) // renvoie -1
```

On voudrait maintenant que cette fonction puisse fonctionner sur d'autres types, comme des `double` ou des `string` (dans ce dernier cas, on prendra le plus grand selon l'ordre alphabétique).

```csharp
FindMax([3.14, 2.71, 1.41]) // renvoie 3.14
FindMax(["apple", "banana", "cherry"]) // renvoie "cherry"
```

Une fonction qui peut prendre différents types d'objets, ça devrait vous faire penser à du polymorphisme avec des interfaces, comme on a vu avec `Filter`. On peut se demander de quoi aurait besoin un telle fonction.

En fait, pour trouver l'élément le plus grand d'une séquence, on a simplement besoin d'une relation d'ordre entre les éléments. Ce que vous avez normalement écrit dans FindMax est un raisonnement en fait récursif :
$$max([x]) = x$$
$$max([x_1, x_2]) = \begin{cases} x_1 & \text{si } x_1 \geq x_2 \\ x_2 & \text{sinon} \end{cases}$$
$$max([x_1, x_2, \ldots, x_n]) = max([max([x_1, x_2]), x_3, \ldots, x_n])$$

Dès lors qu'on peut déterminer si un élément est plus grand qu'un autre, on peut simplement parcourir la séquence en prenant à chaque fois deux éléments et en gardant le plus grand. En parcourant toute la séquence, on se retrouve inévitablement avec le plus grand.

L'ordre entre deux choses est soit $<$, soit $=$, soit $>$.

On peut modéliser ça par une fonction `CompareTo` qui renvoie un entier négatif si l'élément courant est plus petit que l'élément passé en argument, zéro s'ils sont égaux, et un entier positif si l'élément courant est plus grand que l'élément passé en argument :

```csharp
5.CompareTo(3) // 5 > 3 donc renvoie un entier positif
3.CompareTo(5) // 3 < 5 donc renvoie un entier négatif
3.CompareTo(3) // 3 = 3 donc renvoie 0
```

On peut définir une interface `IComparable` qui expose cette méthode `CompareTo` :

```csharp
public interface IComparable
{
    int CompareTo(int other);
}

public struct int : IComparable
{
    ...
    public int CompareTo(int other)
    {
        if (this < other) return -1;
        else if (this > other) return 1;
        else return 0;
    }
}
```

Mais il y a un problème dans cette approche. On voudrait pouvoir également comparer deux `double`. Or, dans notre interface `IComparable`, la méthode `CompareTo` prend un `int` en argument. Ce qu'on voudrait, c'est ça :
```csharp
public struct float : IComparable
{
    ...
    public int CompareTo(float other) // <-- erreur ! l'interface spécifie que other est de type int
    {
        if (this < other) return -1;
        else if (this > other) return 1;
        else return 0;
    }
}
```

En fait, il faudrait que notre interface `IComparable` soit "configurable", c'est-à-dire que le type qui l'implémente puisse spécifier à quoi on peut le comparer. On peut comparer un `int` avec un autre `int`, un `double` avec un autre `double`, etc.

Cette "configurabilité" s'appelle la **généricité**. On dit d'un type qu'il sera générique quand il prend en paramètre un autre type.

Vous avez en fait déjà vu un type générique, il s'agit des tableaux ! En C#, il n'existe en réalité qu'un seul type tableau : `T[]`. Quand vous écrivez `int[]` ou `string[]`, vous créez simplement une "spécialisation" de ce type. On peut imaginer que le type tableau ressemble à ça :
```csharp
public class T[]
{
    public T this[int index]
    {
        get { ... }
        set { ... }
    }
    ...
}
```

Ici, on veut rendre l'interface générique. On va donc écrire :
```csharp
public interface IComparable<T> // les chevrons introduisent un paramètre de type
{
    // l'objet peut être comparé avec un objet de type T
    int CompareTo(T other);
}
```

Il se trouve que cette interface existe déjà en C#, et que tous nos types habituels l'implémentent déjà (`int`, `double`, `string`, etc.).

On va donc modifier la fonction `FindMax` pour qu'elle soit générique elle aussi. Elle prendre une séquence d'éléments de type `T`, où `T` est un type qui implémente l'interface `IComparable<T>`. Elle renverra un élément de type `T`.

Cela se note :
```csharp
public static T FindMax<T>(T[] elements)
    where T : IComparable<T>
{
    ...
}
```
- `<T>` après le nom indique le ou les paramètres de type
- `where` indique les **contraintes** que ce type doit vérifier. Ici, on veut pouvoir effectuer une comparaison entre deux `T`, donc on demande que `T` implémente `IComparable<T>`

Complétez les modifications et vérifiez que votre fonction `FindMax` fonctionne.